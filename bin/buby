#!/usr/bin/env jruby

require File.expand_path(File.join(File.dirname(__FILE__), %w[.. lib buby]))
require 'irb'
require 'optparse'

args = {}

begin
  opts = OptionParser.new do |o|
    o.banner = "Usage: #{File.basename $0} [options]"

    o.on_tail("-h", "--help", "Show this help message") do
      raise opts.to_s
    end

    o.on("-i", "--interactive", "Start IRB") { args[:irb] = true }

    o.on("-d", "--debug", "Debug info") { args[:debug] = true }

    o.on("-B", "--load-burp=PATH", "Load Burp Jar from PATH") do |b|
      args[:load_burp] = b
    end

    o.on('-r', '--restore=FILE', "Restore burpsession on startup") do |r|
      args[:restore] = r
    end

    o.on('-I', '--include=LIB', "require() a Ruby lib after Burp loads") do |i|
      (args[:include] ||= []).push(i)
    end
  end

  opts.parse!(ARGV)

  if jar=args[:load_burp]
    raise "Load Burp Error: #{jar} did not provide burp.StartBurp" unless Buby.load_burp(jar)
  end
  raise "Load Burp Error: Specify a path to your burp.jar with -B" unless Buby.burp_loaded?
rescue
  STDERR.puts $!
  exit 1
end

$DEBUG=true if args[:debug]

$burp = Buby.start_burp()

if libs=args[:include]
  libs.each {|lib| STDERR.puts "loading #{lib}"; require(lib)}
end

if f=args[:restore]
  unless File.exists?(f)
    raise "no such file #{f.inspect}"
  end
  $burp.restore_state(f)
end

if args[:irb]
  # yucky hack...
  IRB.setup(nil)
  IRB.conf[:IRB_NAME] = File.basename($0, ".rb")
  module IRB
    class <<self
      def setup(*args); end
    end
  end
  puts "Global $burp is set to #{$burp.inspect}",
       " Important Note: You'll need to exit by closing the burp window."
  IRB.start()
end

