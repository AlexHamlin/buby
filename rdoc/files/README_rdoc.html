<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Tue Sep 22 18:10:05 -0006 2009</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <p>
buby
</p>
<pre>
  by Eric Monti
  http://emonti.github.com/buby
</pre>
<h2>DESCRIPTION:</h2>
<p>
<a href="../classes/Buby.html">Buby</a> is a mashup of JRuby with the
popular commercial web security testing tool Burp Suite from PortSwigger.
Burp is driven from and tied to JRuby with a Java extension using the
BurpExtender API. This extension aims to add Ruby scriptability to Burp
Suite with an interface comparable to the Burp&#8216;s pure Java extension
interface.
</p>
<h2>FEATURES/PROBLEMS:</h2>
<ul>
<li>Intercept and log proxied requests and responses via Burp into Ruby and
perform arbitrary processing on them.

</li>
<li>Modify requests and responses in-line using Ruby scripts.

</li>
<li>Pass requests and other information from JRuby to various sub-interfaces in
Burp

</li>
<li>Use the Burp framework for active and passive scanning using arbitrary
requests and responses.

</li>
<li>Use the Burp framework for making arbitrary HTTP requests

</li>
</ul>
<p>
<a href="../classes/Buby.html">Buby</a> is implemented using an abstract
Ruby event handler and interface class. The <a
href="../classes/Buby.html">Buby</a> Ruby class is back-ended with a
minimal BurpExtender class implemented in Java. The java code is required
to conform to nuances in the Burp extension interface and while it&#8216;s
in the pure Java runtime, it acts as &#8216;glue&#8217; where deemed
appropriate, but otherwise tries to stay out of the way.
</p>
<p>
The java BurpExtender included with <a href="../classes/Buby.html">Buby</a>
is an implementation of IBurpExtender which is the interface API supplied
by PortSwigger for writing extensions to Burp Suite. It mostly acts as a
method proxy between Ruby and Java, doing very little except event handler
proxying between the java and ruby runtimes with run-time type conversion
as needed.
</p>
<h2>REQUIREMENTS:</h2>
<ul>
<li>JRuby - <a href="http://jruby.org">jruby.org</a> Burp is Java based and the
extension is developed specifically around JRuby. The C version of ruby
will not work.

</li>
<li>Burp (pro or free version): <a href="../classes/Buby.html">Buby</a> is
useless without a copy of Burp. <a href="../classes/Buby.html">Buby</a> has
been tested successfully with Burp 1.2.x.

</li>
</ul>
<h2>BUILD/INSTALL:</h2>
<h3>Gem</h3>
<p>
You should be able to get up and running with just the gem and a copy of
Burp. I&#8216;ve packaged up a pre-built buby.jar file containing the
required classes minus ofcourse, Burp itself.
</p>
<pre>
  jruby -S gem sources -a http://gems.github.com # only have to do this once
  jruby -S gem install emonti-buby
</pre>
<ul>
<li>IMPORTANT: The buby gem doesn&#8216;t include a copy of Burp! See manual
step 5 below. For best results, you&#8216;ll still want to make your
burp.jar available in the ruby runtime library path.

</li>
</ul>
<h3>Manual</h3>
<p>
Here are manual instructions if you want or need to build things yourself:
</p>
<h4>Step 1. Download buby from github</h4>
<pre>
  git clone git://github.com/emonti/buby.git
</pre>
<h4>Step 2. Compile BurpExtender.java. Include jruby.jar in the classpath:</h4>
<pre>
  cd buby/java/src
  javac -classpath (.../jruby/root)/lib/jruby.jar:. BurpExtender.java
</pre>
<h4>Step 3. Create a new java/buby.jar</h4>
<pre>
  jar cvf ../buby.jar .
</pre>
<h4>Step 4. Build a local gem and install it</h4>
<pre>
  cd ../../
  jruby -S gem build buby.gemspec
  jruby -S gem install --local buby-*.gem
</pre>
<h4>Step 5.</h4>
<p>
The last part is a bit tricky. Burp Suite itself is obviously not included
with buby. You&#8216;ll want to somehow put your &#8216;burp.jar&#8217; in
a place where it is visible in the JRuby RUBY-LIB paths. There are a few
other ways of pulling in Burp during runtime, but this method probably
involves the least amount of hassle in the long run.
</p>
<p>
JRuby usually gives you a &#8216;java&#8217; lib directory for this kind of
thing. Here&#8216;s a quick way to see jruby&#8216;s runtime lib-path:
</p>
<pre>
  jruby -e 'puts $:'
</pre>
<p>
There is usually a &#8217;&#8230;/jruby/lib/1.8/java&#8217; directory
reference in there, though the actual directory may need to be created.
</p>
<p>
Here&#8216;s how I do it. I have my jruby installation under my home
directory. Your configuration details can be substituted below.
</p>
<pre>
  mkdir ~/jruby-1.1.5/lib/ruby/1.8/java
  ln -s ~/tools/burp.jar ~/jruby-1.1.5/lib/ruby/1.8/java/burp.jar
</pre>
<p>
Now everything should be ready to go. Try at least the first few parts of
the test below to confirm everything is set up.
</p>
<h2>TEST AND USAGE EXAMPLE:</h2>
<p>
The gem includes a command-line executable called &#8216;buby&#8217;. You
can use this to test your <a href="../classes/Buby.html">Buby</a> set-up
and try out a few features.
</p>
<pre>
  $ buby -h
  Usage: buby [options]
      -i, --interactive          Start IRB
      -d, --debug                Debug info
      -B, --load-burp=PATH       Load Burp Jar from PATH
      -s, --state=FILE           Restore burp state file on startup
      -r, --require=LIB          load a ruby lib (or jar) after Burp loads
      -e, --extend=MOD           Extend Buby with a module (loaded via -r?)
      -h, --help                 Show this help message

  $ buby -i -d
  [:got_extender, #&lt;Java::Default::BurpExtender:0x80 ...&gt;]
  Global $burp is set to #&lt;Buby:0x78de07 @burp_callbacks=#&lt;#&lt;Class:...&gt;
  [:got_callbacks, #&lt;#&lt;Class:01x38ba04&gt;:0x90 ...&gt;]
  irb(main):001:0&gt;
</pre>
<p>
Once Burp is running, click on the alerts tab.
</p>
<p>
You should see now something like the following in alerts:
</p>
<pre>
  2:46:01 PM  suite   method BurpExtender.processProxyMessage() found
  2:46:01 PM  suite   method BurpExtender.registerExtenderCallbacks() found
  2:46:01 PM  suite   method BurpExtender.setCommandLineArgs() found
  2:46:01 PM  suite   method BurpExtender.applicationClosing() found
  2:46:01 PM  proxy   proxy service started on port 8080
  2:46:01 PM  suite   [BurpExtender] registering JRuby handler callbacks
  2:46:01 PM  suite   [JRuby::Buby] registered callback
</pre>
<p>
Here are some simple test examples using <a
href="../classes/Buby.html">Buby</a> through the IRB shell:
</p>
<p>
To confirm you are connected back to Burp in IRB, you can try writing to
the alerts panel with something like the following:
</p>
<pre>
  $burp.alert(&quot;hello Burp!&quot;)
</pre>
<p>
Which should produce a new alert:
</p>
<pre>
  2:47:00 PM  suite   hello Burp!
</pre>
<p>
Next, try making an HTTP request through the proxy. We&#8216;ll use
Net:HTTP right in IRB for illustration purposes. However, you can just as
easily perform this test through a browser configured to use Burp as its
proxy.
</p>
<pre>
  require 'net/http'
  p = Net::HTTP::Proxy(&quot;localhost&quot;, 8080).start(&quot;www.example.com&quot;)
  p.get(&quot;/&quot;)
</pre>
<p>
With $DEBUG = true, you should see the debugging output from Ruby as the
proxy passes your request back to your HTTP client/browser.
</p>
<p>
It will look something like the following in IRB:
</p>
<pre>
  &gt;&gt; p.get(&quot;/&quot;)
  [:got_proxy_request,
   [:msg_ref, 1],
   [:is_req, true],
   [:rhost, &quot;www.example.com&quot;],
   [:rport, 80],
   [:is_https, false],
   [:http_meth, &quot;GET&quot;],
   [:url, &quot;/&quot;],
   [:resourceType, nil],
   [:status, nil],
   [:req_content_type, nil],
   [:message, &quot;GET / HTTP/1.1\r\nAccept:...&quot;],
   [:action, 0]]
</pre>
<p>
You may also see the response right away depending on your intercept
settings in Burp. Back the in Burp proxy&#8216;s intercept window, turn off
interception if it hasn&#8216;t already been disabled. Now you should
definitely see the response in IRB as it passes back through the Burp
proxy.
</p>
<pre>
  [:got_proxy_response,
   [:msg_ref, 1],
   [:is_req, false],
   [:rhost, &quot;www.example.com&quot;],
   [:rport, 80],
   [:is_https, false],
   [:http_meth, &quot;GET&quot;],
   [:url, &quot;/&quot;],
   [:resourceType, nil],
   [:status, &quot;200&quot;],
   [:req_content_type, &quot;text/html; charset=utf-8&quot;],
   [:message, &quot;HTTP/1.1 200 OK\r\n...&quot;],
   [:action, 0]]
  =&gt; #&lt;Net::HTTPOK 200 OK readbody=true&gt;
  &gt;&gt;
</pre>
<p>
Note also, the Net::HTTP request should have returned the same result as
shown in the proxy.
</p>
<p>
Now, lets try something mildly interesting with the proxy. This contrived
example will implement a proxy request manipulator to do HTTP request verb
tampering on every GET request that goes through the proxy.
</p>
<pre>
  # Note: I'm using 'instance_eval' here only to stay with the flow of the
  # existing IRB session. Normally, you'd probably want to implement this as
  # an override in your Buby-derived class.

  $burp.instance_eval do

    def evt_proxy_message(*param)
      msg_ref, is_req, rhost, rport, is_https, http_meth, url, resourceType,
      status, req_content_type, message, action = param

      if is_req and http_meth==&quot;GET&quot;
        # Change the HTTP request verb to something silly
        message[0,3] = &quot;PET&quot;

        # Forcibly disable interception in the Burp UI
        action[0] = Buby::ACTION_DONT_INTERCEPT

        # Return a new instance and still get $DEBUG info
        return super(*param).dup
      else
        # Just get $DEBUG info for all other requests
        return super(*param)
      end
    end

  end

  # Now, make another request using the Net::HTTP client
  p.get(&quot;/&quot;)
</pre>
<p>
This should produce a request that looks like the following in IRB:
</p>
<pre>
  [:got_proxy_request,
   ...
   [:message,
    &quot;PET / HTTP/1.1\r\nAccept: */*\r\nUser-Agent: Ruby...&quot;],
    [:action, 2]]
</pre>
<p>
And, assuming &#8216;<a
href="http://www.example.com">www.example.com</a>&#8217; checks for valid
request verbs, you should see something like the following response:
</p>
<pre>
  [:got_proxy_response,
   ...
   [:http_meth, &quot;PET&quot;],
   [:url, &quot;/&quot;],
   [:resourceType, nil],
   [:status, &quot;400&quot;],
   ...
   [:message,
    &quot;HTTP/1.1 400 Bad Request\r\nContent-Type:...&quot;],
   [:action, 0]]
  =&gt; #&lt;Net::HTTPBadRequest 400 Bad Request readbody=true&gt;
</pre>
<h2>CREDIT:</h2>
<ul>
<li>Burp and Burp Suite are trademarks of PortSwigger(ltd) Copyright 2008
PortSwigger Ltd. All rights reserved. See <a
href="http://portswigger.net">portswigger.net</a> for license terms.

</li>
<li>This ruby library and the accompanying BurpExtender.java implementation are
written by Eric Monti @ Matasano Security. Matasano Security claims no
professional or legal affiliation with PortSwigger LTD.

<p>
However, the author would like to express his personal and professional
respect and admiration to Burp&#8216;s authors and appreciation to
PortSwigger for the availability of the IBurpExtender extension API.
</p>
<p>
The availability of this interface goes a long way to helping make Burp
Suite a truly first-class application.
</p>
</li>
</ul>
<h2>LICENSE:</h2>
<ul>
<li>Burp and Burp Suite are trademarks of PortSwigger Ltd. Copyright 2008
PortSwigger Ltd. All rights reserved. See <a
href="http://portswigger.net">portswigger.net</a> for license terms.

</li>
<li>The <a href="../classes/Buby.html">Buby</a> Ruby library and its
accompanying BurpExtender implementation are both freely available under
the terms of the MIT public license:

</li>
</ul>
<p>
(The MIT License)
</p>
<p>
Copyright (C) 2009 Eric Monti, Matasano Security
</p>
<p>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
&#8216;Software&#8217;), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to the
following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED &#8216;AS IS&#8217;, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>